gsap.registerPlugin(PixiPlugin);
gsap.registerPlugin(MotionPathPlugin);

let langCode = "en";

(() => {
    let searchText = window.location.search;
    if (searchText.length) {
        let lang = searchText.substring(1).split("=");
        if (lang.length > 0 && lang[0] == "lang") {
            langCode = lang[1];
        }
    }
})();

let textContent = {
    en: {
        l1: "Map fields",
        l2: "Track jobs",
        l3: "Take notes",
        l4: "Log harvest",
        l5: "Invite team members",
        l6: "Submit hours worked",
        l7: "Alerts",
        r1: "Fields overview",
        r2: "Jobs and Harvest review",
        r3: "Add product details for compliance",
        rb1: [
            "Reporting Module",
            "Audit ready treatment reports",
            "Autogenerated jobs and harvest logs"
        ],
        rb2: ["Teams and Timesheets Module", "Team management", "Timesheets"],
        rb3: ["Safe Spraying Module", "Field access limitations", "Label restriction alerts"],
        btm: ["Free", "Paid add-on modules"]
    },
    de: {
        l1: "Schläge zeichnen",
        l2: "Arbeiten erfassen",
        l3: "Notizen schreiben",
        l4: "Ernte eintragen",
        l5: "Team einladen",
        l6: "Arbeitsstunden erfassen",
        l7: "Warnhinweise",
        r1: "Übersicht aller Schläge",
        r2: "Übersicht aller Arbeiten und Erträge",
        r3: "Ergänze Pflanzenschutzmittelangaben für regelkonforme Dokumentation",
        rb1: [
            'Zusatzmodul "Berichterstattung"',
            "Auditfähige Pflanzenschutzdo kumentation",
            "Erstelle Spritz- und Ernteprotokolle mit einem Klick"
        ],
        rb2: ['Zusatzmodul "Zeiterfassung"', "Mitarbeiter & Teams verwalten", "Stundenzettel"],
        rb3: [
            'Zusatzmodul "Sicheres Sprühen"',
            "Wartezeiten kenntlich machen & einhalten",
            "Warnhinweise Präparatangaben"
        ],
        btm: ["Kostenlos", "Kostenpflichtige Zusatzmodule"]
    },
    es: {
        l1: "Campos del mapa",
        l2: "Haz un seguimiento de los trabajos",
        l3: "Toma notas",
        l4: "Registra la cosecha",
        l5: "Invita a los miembros del equipo",
        l6: "Envía horas de trabajo",
        l7: "Alertas",
        r1: "Visión general de los Campos",
        r2: "Revisión de Trabajos y Cosechas",
        r3: "Agregue detalles del producto para cumplimiento",
        rb1: [
            "Módulo de informes",
            "Informes de tratamiento listos para auditoría",
            "Trabajos y registros de cosecha generados automáticamente"
        ],
        rb2: ["Módulo de equipos y partes de horas", "Gestión de equipos", "Hojas de horas"],
        rb3: [
            "Módulo de pulverización segura",
            "Limitaciones de acceso al campo",
            "Alertas de restricción de etiquetas"
        ],
        btm: ["Gratis", "Módulos complementarios pagados"]
    }
};

let dpr = window.devicePixelRatio;
let resolution = dpr < 2 ? 2 : dpr;
if (window.innerWidth < 1025) resolution = 3;
PIXI.settings.RESOLUTION = PIXI.settings.FILTER_RESOLUTION = resolution;

let color_lightGreen = 0xf0f8f4; //0x990099;
let color_darkGreen = 0x00843d;
let color_darkOrange = 0xcf4520;
let color_lightOrange = 0xfcf4f2;
let color_lightGray = 0xf2f2f2; //0x009999;
let color_darkGray = 0xd0d0d0;
let animate = null;
let t1 = null;

const app = new PIXI.Application({
    width: 960,
    height: 602,
    antialias: true,
    backgroundAlpha: 0
});

let textElemList = [];

//Add the canvas that Pixi automatically created for you to the HTML document
document.getElementById("animation-container").appendChild(app.view);
//PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
let imageAliases = [
    "logo1.png",
    "l_icon_1.png",
    "l_icon_2.png",
    "l_icon_3.png",
    "l_icon_4.png",
    "l_icon_5.png",
    "l_icon_6.png",
    "l_icon_7.png",
    "r_icon_1.png",
    "r_icon_2.png",
    "r_icon_3.png",
    "r_icon_11.png",
    "r_icon_21.png",
    "r_icon_31.png",
    "logo_mobile_app.png",
    "logo_web_portal.png"
];
let imagesFolderPath = "images";
let images = imageAliases.map((i) => `${imagesFolderPath}/${i}`);

WebFont.load({
    custom: {
        families: ["Raleway:n4,n5,n6,n7"]
    },
    active: function () {
        // console.log("fonts loaded");
        PIXI.Loader.shared.add(images).load(setupAnimations);
    }
});

//This `setup` function will run when the image has loaded

let GetSprite = (alias) => {
    let imageAlias = imageAliases.filter((img) => img.split(".")[0] === alias)[0];
    return new PIXI.Sprite(PIXI.Loader.shared.resources[`images/${imageAlias}`].texture);
};

let createIconTextGroupItemWidth = 140;
let lBoxX = 15;
let rBoxX = 615;
let createIconTextGroupItem = (textStr, textureName, num) => {
    let container = new PIXI.Container();

    let containerW = createIconTextGroupItemWidth;
    let containerH = 50;
    if (langCode === "es" && num === 2) {
        containerH = 80;
    }
    if (langCode === "es" && num === 5) {
        containerH = 65;
    }

    const rectangle = new PIXI.Graphics();
    rectangle.lineStyle({ width: 1, color: 0xf1f1f1, alpha: 1 });
    rectangle.beginFill(0xffffff);
    rectangle.drawRoundedRect(0, 0, containerW, containerH, 1);
    rectangle.endFill();
    var dropShadowFilter = new PIXI.filters.DropShadowFilter();
    dropShadowFilter.color = 0x444444;
    dropShadowFilter.rotation = 90;
    dropShadowFilter.alpha = 0.1;
    dropShadowFilter.blur = 4;
    dropShadowFilter.distance = 7;
    dropShadowFilter.quality = 10;
    rectangle.filters = [dropShadowFilter];
    container.addChild(rectangle);

    let icon = GetSprite(textureName); // new PIXI.Sprite(PIXI.Loader.shared.resources[textureName].texture);
    icon.anchor.set(0.5, 0.5);
    icon.width = (icon.width / icon.height) * 20;
    icon.height = 20;
    icon.position.set(20, containerH / 2);
    container.addChild(icon);

    const textLabel = new PIXI.Text(textStr, {
        fontFamily: "Raleway",
        fontSize: 13,
        fontWeight: 600,
        fill: "#000000",
        wordWrap: true,
        wordWrapWidth: 90,
        align: "left"
    });
    textElemList.push(textLabel);
    textLabel.anchor.set(0, 0.5);
    textLabel.position.set(37, containerH / 2);
    container.addChild(textLabel);

    viewport.addChild(container);
    return container;
};
const viewport = new pixi_viewport.Viewport({
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: 960,
    worldHeight: 602,

    interaction: app.renderer.plugins.interaction // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
});
app.stage.addChild(viewport);
let createText = (textStr, txtColor, x, y) => {
    const textLabel = new PIXI.Text(textStr, {
        fontFamily: "Raleway",
        fontSize: 16.4,
        fontWeight: 500,
        fill: txtColor,
        wordWrap: true,
        wordWrapWidth: 360,
        align: "left"
    });
    textElemList.push(textLabel);
    textLabel.anchor.set(0, 0.5);
    textLabel.x = x;
    textLabel.y = y;

    viewport.addChild(textLabel);
    return textLabel;
};

let createCircle = (fill, radius, x = 10, y = 10, lineFill = 0xffffff, lineWidth = 0) => {
    const circle = new PIXI.Graphics();
    circle.lineStyle({ width: lineWidth, color: lineFill, alpha: 1 });
    circle.beginFill(fill);
    circle.drawCircle(0, 0, radius);
    circle.endFill();
    circle.x = x;
    circle.y = y;
    viewport.addChild(circle);
    return circle;
};

let createTriangle = (x = 0, y = 0, fill = 0x1b823a, reverse = false) => {
    let tri1 = new PIXI.Graphics();
    tri1.beginFill(fill);
    let w = 15;
    let h = 18;
    tri1.drawCircle(0, 0, 5);
    tri1.endFill();
    tri1.x = x;
    tri1.y = y;
    tri1.alpha = 0;
    //tri1.pivot.set(7.5, -9);
    viewport.addChild(tri1);
    return tri1;
};

let drawLine = (style, pos, points, fill = false) => {
    let line = new PIXI.Graphics();

    if (fill) line.beginFill(fill);
    line.lineStyle(style); //eaf3ee
    line.moveTo(points[0].x, points[0].y);

    let path = `M${points[0].x + pos.x},${points[0].y + pos.y} `;

    points.forEach((pt, i) => {
        if (i === 0) return;
        if (pt.curve) {
            //line.moveTo(pt.x - pt.curve, points[0].y);
            let ppt = points[i - 1];
            let npt = points[i + 1];

            let prevPtX = pt.x !== ppt.x ? pt.x + (ppt.x > pt.x ? pt.curve : -pt.curve) : pt.x;
            let prevPtY = pt.y !== ppt.y ? pt.y + (ppt.y > pt.y ? pt.curve : -pt.curve) : pt.y;
            //console.log("prev", prevPtX, prevPtY);
            let nextPtX = pt.x !== npt.x ? pt.x + (npt.x > pt.x ? pt.curve : -pt.curve) : pt.x;
            let nextPtY = pt.y !== npt.y ? pt.y + (npt.y > pt.y ? pt.curve : -pt.curve) : pt.y;
            //console.log("next", nextPtX, nextPtY);

            line.lineTo(prevPtX, prevPtY);
            line.quadraticCurveTo(pt.x, pt.y, nextPtX, nextPtY);

            path += `L${prevPtX + pos.x},${prevPtY + pos.y} `;
            path += `Q${pt.x + pos.x},${pt.y + pos.y} ${nextPtX + pos.x},${nextPtY + pos.y} `;
        } else {
            line.lineTo(pt.x, pt.y);
            path += `L${pt.x + pos.x},${pt.y + pos.y} `;
        }
    });
    if (fill) line.endFill(fill);

    line.x = pos.x;
    line.y = pos.y;
    viewport.addChild(line);

    //console.log(path);
    return { obj: line, path };
};

viewport.on("zoomed-end", () => {
    console.log("zoomed");
    let res = viewport.scaled < 2 ? 2 : viewport.scaled;

    textElemList.forEach((t) => {
        t.resolution = res;
    });
});

let createBigBoxWithText = (t1, t2, t3, i1, i2, i3, boxNum) => {
    let container = new PIXI.Container();
    let lineStyle3 = { width: 1, color: color_darkOrange, alpha: 1 };
    let boxHt = 83;
    if (langCode !== "en" && boxNum !== 1) {
        boxHt = 105;
    }
    let boxOutline = drawLine(
        lineStyle3,
        { x: 0, y: 0 },
        [
            { x: 0, y: 0 },
            { x: 341, y: 0, curve: 22 },
            { x: 341, y: boxHt, curve: 22 },
            { x: 0, y: boxHt },
            { x: 0, y: 0 }
        ],
        0xffffff
    );
    container.addChild(boxOutline.obj);

    let boxLine1 = drawLine(lineStyle3, { x: 10, y: 35 }, [
        { x: 0, y: 0 },
        { x: 320, y: 0 }
    ]);
    container.addChild(boxLine1.obj);

    const mainText = new PIXI.Text(t1, {
        fontFamily: "Raleway",
        fontSize: 15.7,
        fontWeight: 600,
        fill: color_darkOrange,
        wordWrap: true,
        wordWrapWidth: 360,
        align: "left"
    });
    textElemList.push(mainText);
    mainText.anchor.set(0, 0.5);
    mainText.x = 40;
    mainText.y = 18;
    container.addChild(mainText);

    const txt1 = new PIXI.Text(t2, {
        fontFamily: "Raleway",
        fontSize: 13.4,
        fontWeight: 500,
        fill: color_darkOrange,
        wordWrap: true,
        wordWrapWidth: 115,
        align: "left"
    });
    textElemList.push(txt1);
    txt1.anchor.set(0, 0.5);
    txt1.x = 40;
    if (langCode === "en") {
        txt1.y = 57;
    } else {
        if (boxNum !== 1) {
            txt1.y = 70;
        } else {
            txt1.y = 57;
        }
    }
    container.addChild(txt1);

    const txt2 = new PIXI.Text(t3, {
        fontFamily: "Raleway",
        fontSize: 13.5,
        fontWeight: 500,
        fill: color_darkOrange,
        wordWrap: true,
        wordWrapWidth: 130,
        align: "left",
        lineHeight: 15
    });
    textElemList.push(txt2);
    txt2.anchor.set(0, 0.5);
    txt2.x = 200;
    if (langCode === "en") {
        txt2.y = 57;
    } else {
        if (boxNum !== 1) {
            txt2.y = 70;
        } else {
            txt2.y = 57;
        }
    }
    container.addChild(txt2);

    let mainImg = GetSprite(i1);
    mainImg.anchor.set(0.5, 0.5);
    mainImg.width = (mainImg.width / mainImg.height) * 20;
    mainImg.height = 20;
    mainImg.x = 20;
    mainImg.y = 18;
    container.addChild(mainImg);

    let iconImg1 = GetSprite(i2);
    iconImg1.anchor.set(0.5, 0.5);
    iconImg1.width = (iconImg1.width / iconImg1.height) * 22;
    iconImg1.height = 22;
    iconImg1.x = 20;
    if (langCode === "en") {
        iconImg1.y = 57;
    } else {
        if (boxNum !== 1) {
            iconImg1.y = 70;
        } else {
            iconImg1.y = 57;
        }
    }
    container.addChild(iconImg1);

    let iconImg2 = GetSprite(i3);
    iconImg2.anchor.set(0.5, 0.5);
    iconImg2.width = (iconImg2.width / iconImg2.height) * 22;
    iconImg2.height = 22;
    iconImg2.x = 180;
    if (langCode === "en") {
        iconImg2.y = 57;
    } else {
        if (boxNum !== 1) {
            iconImg2.y = 70;
        } else {
            iconImg2.y = 57;
        }
    }
    container.addChild(iconImg2);

    viewport.addChild(container);
    return container;
};

let setupStaticLogoText = function () {
    let logoMob = GetSprite("logo_mobile_app");
    logoMob.anchor.set(1, 0.5);
    logoMob.position.set(40, 27);
    logoMob.width = (logoMob.width / logoMob.height) * 31;
    logoMob.height = 31;
    viewport.addChild(logoMob);
    createText("Mobile App", 0x000000, 50, 27);

    let logoWeb = GetSprite("logo_web_portal");
    logoWeb.anchor.set(1, 0.5);
    logoWeb.position.set(649, 27);
    logoWeb.width = (logoWeb.width / logoWeb.height) * 31;
    logoWeb.height = 31;
    viewport.addChild(logoWeb);
    createText("Web Portal", 0x000000, 659, 27);

    let c1x = 730;
    let c2x = 805;
    if (langCode === "de") {
        c1x = 640;
        c2x = 742;
    }
    if (langCode === "es") {
        c1x = 635;
        c2x = 712;
    }

    createCircle(color_darkGreen, 8.5, c1x, 575);
    const text_free = new PIXI.Text(textContent[langCode].btm[0], {
        fontFamily: "Raleway",
        fontSize: 13.7,
        fontWeight: 500,
        fill: color_darkGreen,
        wordWrap: true,
        wordWrapWidth: 360,
        align: "left"
    });
    textElemList.push(text_free);
    text_free.anchor.set(0, 0.5);
    text_free.position.set(c1x + 14, 575);
    viewport.addChild(text_free);

    createCircle(color_darkOrange, 8.5, c2x, 575);
    const text_paid = new PIXI.Text(textContent[langCode].btm[1], {
        fontFamily: "Raleway",
        fontSize: 13.7,
        fontWeight: 500,
        fill: color_darkOrange,
        wordWrap: true,
        wordWrapWidth: 360,
        align: "left"
    });
    textElemList.push(text_paid);
    text_paid.anchor.set(0, 0.5);
    text_paid.position.set(c2x + 14, 575);
    viewport.addChild(text_paid);
};

if (window.innerWidth < 1025) {
    viewport.drag().pinch().wheel().clampZoom({ minScale: 1 }); //.decelerate();
}
let drawDashedLine = (points, lineStyle, dashOptions, pos) => {
    let newPoints = [];
    newPoints.push(points[0]);

    //console.table(points);
    //console.table(newPoints);
    const line = viewport.addChild(new PIXI.Graphics());
    line.lineStyle(lineStyle); //eaf3ee
    line.moveTo(points[0].x, points[0].y);

    let getLinePoint = (p1, p2, distance) => {
        let x = 0;
        let y = 0;

        let xDiff = p2.x - p1.x;
        let yDiff = p2.y - p1.y;
        let length = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        let ratio = distance / length;

        x = xDiff * ratio;
        y = yDiff * ratio;

        return { x, y };
    };

    let drawDashes = (from, to) => {
        let xDiff = to.x - from.x;
        let yDiff = to.y - from.y;
        let length = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        let distanceCovered = 0;
        let ratioDsh = dashOptions[0] / length; // dash length
        let ratioGap = dashOptions[1] / length; // gap length

        let drawGap = false;
        let curPt = { ...from };

        while (distanceCovered < length) {
            if (drawGap) {
                let lp = getLinePoint(from, to, dashOptions[1]);
                curPt.x += lp.x;
                curPt.y += lp.y;
                line.moveTo(curPt.x, curPt.y);
                distanceCovered += dashOptions[1];
            } else {
                let lp = getLinePoint(from, to, dashOptions[0]);
                curPt.x += lp.x;
                curPt.y += lp.y;
                line.lineTo(curPt.x, curPt.y);
                distanceCovered += dashOptions[0];
            }
            drawGap = !drawGap;
        }
        //console.log(from, to, distance);
    };

    let curPos = points[0];
    //console.log(points);

    let getLength = (from, to) => {
        let xDiff = to.x - from.x;
        let yDiff = to.y - from.y;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    };

    let dshLen = dashOptions[0];
    let gapLen = dashOptions[1];
    //let drawDash = true;

    points.forEach((pt, i) => {
        let drawDash = true;
        pt = { ...pt };
        let nPt = points[i + 1];
        if (nPt) {
            nPt = { ...nPt };
        }
        let curLen = 0;
        if (nPt) {
            let lineLength = getLength(pt, nPt);

            if (nPt.curve) {
                let newPt = getLinePoint(pt, nPt, nPt.curve);
                nPt.x -= newPt.x;
                nPt.y -= newPt.y;
                lineLength -= nPt.curve;
                //console.log(i, pt, newPt, nPt);
                //createCircle(color_darkGreen, 3, nPt.x + pos.x, nPt.y + pos.y);
            }
            if (pt.curve) {
                let newPt = getLinePoint(pt, nPt, pt.curve);
                //console.log(i, pt, newPt);
                pt.x += newPt.x;
                pt.y += newPt.y;
                lineLength -= pt.curve;
                // console.log(i, pt, newPt, nPt);
                line.moveTo(pt.x, pt.y);
                curPos = pt;
                //createCircle(color_darkOrange, 3, pt.x + pos.x, pt.y + pos.y);
            }

            while (curLen < lineLength) {
                let len = drawDash ? dshLen : gapLen;
                let newPt = getLinePoint(pt, nPt, len);
                curPos.x += newPt.x;
                curPos.y += newPt.y;

                //curPos.x = curPos.x > nPt.x ? nPt.x : curPos.x;
                //curPos.y = curPos.y > nPt.y ? nPt.y : curPos.y;

                if (drawDash) {
                    line.lineTo(curPos.x, curPos.y);

                    //console.log("lineTo", i, curPos.x, curPos.y);
                } else {
                    line.moveTo(curPos.x, curPos.y);
                }
                drawDash = !drawDash;
                curLen += len;
            }

            line.moveTo(nPt.x, nPt.y);
        }
    });

    line.x = pos.x;
    line.y = pos.y;
    return line;
};

function setupAnimations() {
    let isDebugMode = false;
    setupStaticLogoText();

    let logoBgCircle1 = createCircle(0xfdf8f6, 45, 392.75, 248.25, 0x1b823a, 0);
    let logoBgCircle2 = createCircle(0xfaedea, 38, 392.75, 248.25, 0x1b823a, 0);
    let logoBgCircle3 = createCircle(0xf6dfdc, 32, 392.75, 248.25, 0x1b823a, 0);

    let mainLogo = GetSprite("logo1");
    mainLogo.position.set(392.75, 248.25);
    mainLogo.anchor.set(0.5, 0.5);
    mainLogo.width = mainLogo.height = 52;
    viewport.addChild(mainLogo);

    gsap.fromTo(
        mainLogo,
        {
            pixi: { width: 30, height: 30, alpha: 0, rotation: 90 }
        },
        {
            pixi: { width: 52, height: 52, alpha: 1, rotation: 0 },
            duration: 1
        }
    );

    let colorMatrix = new PIXI.filters.ColorMatrixFilter();
    colorMatrix.greyscale(0.7, true);
    console.log(textContent[langCode].l1);
    let lItemH = 58;
    let leftItem1 = createIconTextGroupItem(textContent[langCode].l1, "l_icon_1", 1);
    leftItem1.position.set(lBoxX, 90);
    if (langCode === "es") {
        leftItem1.position.set(lBoxX, 90 - 30);
    }
    if (!isDebugMode) leftItem1.alpha = 0;

    let leftItem2 = createIconTextGroupItem(textContent[langCode].l2, "l_icon_2", 2);
    leftItem2.position.set(lBoxX, 90 + lItemH * 1);
    if (langCode === "es") {
        leftItem2.position.set(lBoxX, 90 - 30 + lItemH * 1);
    }
    if (!isDebugMode) leftItem2.alpha = 0;

    let leftItem3 = createIconTextGroupItem(textContent[langCode].l3, "l_icon_3", 3);
    leftItem3.position.set(lBoxX, 90 + lItemH * 2);
    if (!isDebugMode) leftItem3.alpha = 0;

    let leftItem4 = createIconTextGroupItem(textContent[langCode].l4, "l_icon_4", 4);
    leftItem4.position.set(lBoxX, 90 + lItemH * 3);
    if (!isDebugMode) leftItem4.alpha = 0;

    let leftItem5 = createIconTextGroupItem(textContent[langCode].l5, "l_icon_5", 5);
    leftItem5.position.set(lBoxX, 90 + lItemH * 4);
    if (!isDebugMode) leftItem5.alpha = 0;

    let leftItem6 = createIconTextGroupItem(textContent[langCode].l6, "l_icon_6", 6);
    leftItem6.position.set(lBoxX, 400);
    if (!isDebugMode) leftItem6.alpha = 0;
    let leftItem6Sprite = leftItem6.children[1];
    let leftItem6Text = leftItem6.children[2];
    leftItem6Text.style.fill = color_darkOrange;
    //leftItem6Sprite.filters = [colorMatrix];

    let lBox7Xoffset = 38;
    let leftItem7 = createIconTextGroupItem(textContent[langCode].l7, "l_icon_7");
    leftItem7.position.set(lBoxX + lBox7Xoffset, 470);
    if (!isDebugMode) leftItem7.alpha = 0;
    let leftItem7Sprite = leftItem7.children[1];
    let leftItem7Text = leftItem7.children[2];
    leftItem7Text.style.fill = color_darkOrange;
    //leftItem7Sprite.filters = [colorMatrix];

    let lCircleXPos = createIconTextGroupItemWidth + lBoxX + 20;
    let l1y = langCode === "es" ? -30 : 0;
    let l2y = langCode === "es" ? -15 : 0;

    createCircle(color_lightGreen, 10, lCircleXPos, l1y + 115 + lItemH * 0);
    createCircle(color_lightGreen, 10, lCircleXPos, l2y + 115 + lItemH * 1);
    createCircle(color_lightGreen, 10, lCircleXPos, 115 + lItemH * 2);
    createCircle(color_lightGreen, 10, lCircleXPos + 160, 115 + lItemH * 2);
    createCircle(color_lightGreen, 10, lCircleXPos, 115 + lItemH * 3);
    createCircle(color_lightGreen, 10, lCircleXPos, 115 + lItemH * 4);

    let lBGCircle6_1 = createCircle(color_lightOrange, 10, lCircleXPos, 395 + lItemH / 2);
    let lBGCircle6_2 = createCircle(color_lightOrange, 10, 334, 259);
    let lBGCircle7_1 = createCircle(
        color_lightOrange,
        10,
        lCircleXPos + lBox7Xoffset,
        465 + lItemH / 2
    );
    let lBGCircle7_2 = createCircle(color_lightOrange, 10, 345, 289);

    let rLinePathX = 450;
    let rLinePathEndX = 590;

    createCircle(color_lightGreen, 10, rLinePathX, 231);
    let rBGCircle_l2_1 = createCircle(color_lightOrange, 10, rLinePathX, 259);

    createCircle(color_lightGreen, 10, rLinePathEndX, 81);
    createCircle(color_lightGreen, 10, rLinePathEndX, 81 + 53);
    createCircle(color_lightGreen, 10, rLinePathEndX, 81 + 53 + 53);

    let rl5Offset = 0;
    let rl6Offset = 0;
    if (langCode !== "en") rl5Offset = 22;
    if (langCode !== "en") rl6Offset = 10;
    let rBGCircle4_2 = createCircle(color_lightOrange, 10, rLinePathEndX, 259);
    let rBGCircle5_2 = createCircle(color_lightOrange, 10, rLinePathEndX, 259 + 97 + rl5Offset);
    let rBGCircle6_2 = createCircle(
        color_lightOrange,
        10,
        rLinePathEndX,
        259 + 97 + 97 + rl5Offset + rl6Offset
    );

    let bgLineStyle = { width: 20, color: color_lightGreen, alpha: 1 };
    let lineStyle = { width: 2.5, color: color_darkGreen, alpha: 1 };
    let dashLineStyle1 = { width: 2.5, color: color_lightGreen, alpha: 1 };
    let bgLineStyle2 = { width: 20, color: color_lightOrange, alpha: 1 };
    let lineStyle2 = { width: 2.5, color: color_darkOrange, alpha: 1 };
    let dashLineStyle2 = { width: 2.5, color: color_lightOrange, alpha: 1 };
    let bgLineStyle3 = { width: 20, color: color_lightOrange, alpha: 1 };
    let lineStyle3 = { width: 2.5, color: color_darkOrange, alpha: 1 };
    let dashLineStyle3 = { width: 2.5, color: color_lightGray, alpha: 1 };
    let thinLineCurve = 10;
    let leftLineX1 = 90;
    let leftLineX2 = 160;

    let line1Path = [
        { x: 0, y: l1y },
        { x: leftLineX1, y: l1y, curve: thinLineCurve },
        { x: leftLineX1, y: lItemH * 2, curve: thinLineCurve },
        { x: leftLineX2, y: lItemH * 2 }
    ];

    let line2Path = [
        { x: 0, y: l2y },
        { x: leftLineX1, y: l2y, curve: thinLineCurve },
        { x: leftLineX1, y: lItemH, curve: thinLineCurve },
        { x: leftLineX2, y: lItemH }
    ];
    let line3Path = [
        { x: 0, y: 0 },
        { x: leftLineX1, y: 0 },
        { x: leftLineX2, y: 0 }
    ];
    let line4Path = [
        { x: 0, y: 0 },
        { x: leftLineX1, y: 0, curve: thinLineCurve },
        { x: leftLineX1, y: -lItemH, curve: thinLineCurve },
        { x: leftLineX2, y: -lItemH }
    ];
    let line5Path = [
        { x: 0, y: 0 },
        { x: leftLineX1, y: 0, curve: thinLineCurve },
        { x: leftLineX1, y: -lItemH * 2, curve: thinLineCurve },
        { x: leftLineX2, y: -lItemH * 2 }
    ];

    let line6Path = [
        { x: 0, y: 0 },
        { x: 118, y: 0, curve: 10 },
        { x: 118, y: -165, curve: 10 },
        { x: leftLineX2, y: -165 }
    ];

    let line7Path = [
        { x: 132, y: -205 },
        { x: 105, y: -205, curve: 10 },
        { x: 105, y: 0, curve: 10 },
        { x: 0, y: 0 }
    ];

    let rightLine1Path = [
        { x: 0, y: 0 },
        { x: 48, y: 0, curve: 10 },
        { x: 48, y: -150, curve: 10 },
        { x: 140, y: -150 }
    ];
    let rightLine2Path = [
        { x: 0, y: 0 },
        { x: 48, y: 0, curve: 10 },
        { x: 48, y: -97, curve: 10 },
        { x: 140, y: -97 }
    ];
    let rightLine3Path = [
        { x: 0, y: 0 },
        { x: 48, y: 0, curve: 10 },
        { x: 48, y: -44, curve: 10 },
        { x: 140, y: -44 }
    ];

    let rightLine4Path = [
        { x: 0, y: 0 },
        { x: 140, y: 0 }
    ];
    let rightLine5Path = [
        { x: 0, y: 0 },
        { x: 48, y: 0, curve: 10 },
        { x: 48, y: 97 + rl5Offset, curve: 10 },
        { x: 140, y: 97 + rl5Offset }
    ];
    let rightLine6Path = [
        { x: 0, y: 0 },
        { x: 48, y: 0, curve: 10 },
        { x: 48, y: 194 + rl5Offset + rl6Offset, curve: 10 },
        { x: 140, y: 194 + rl5Offset + rl6Offset }
    ];

    let bgLine1 = drawLine(bgLineStyle, { x: lCircleXPos, y: 115 + lItemH * 0 }, line1Path);
    let bgLine2 = drawLine(bgLineStyle, { x: lCircleXPos, y: 115 + lItemH * 1 }, line2Path);
    let bgLine3 = drawLine(bgLineStyle, { x: lCircleXPos, y: 115 + lItemH * 2 }, line3Path);
    let bgLine4 = drawLine(bgLineStyle, { x: lCircleXPos, y: 115 + lItemH * 3 }, line4Path);
    let bgLine5 = drawLine(bgLineStyle, { x: lCircleXPos, y: 115 + lItemH * 4 }, line5Path);
    let bgLine6 = drawLine(bgLineStyle3, { x: lCircleXPos, y: 395 + lItemH / 2 }, line6Path);
    let bgLine7 = drawLine(
        bgLineStyle3,
        { x: lCircleXPos + lBox7Xoffset, y: 465 + lItemH / 2 },
        line7Path
    );

    let line1 = drawLine(lineStyle, { x: lCircleXPos, y: 115 + lItemH * 0 }, line1Path);
    if (!isDebugMode) line1.obj.alpha = 0;
    let line2 = drawLine(lineStyle, { x: lCircleXPos, y: 115 + lItemH * 1 }, line2Path);
    if (!isDebugMode) line2.obj.alpha = 0;
    let line3 = drawLine(lineStyle, { x: lCircleXPos, y: 115 + lItemH * 2 }, line3Path);
    if (!isDebugMode) line3.obj.alpha = 0;
    let line4 = drawLine(lineStyle, { x: lCircleXPos, y: 115 + lItemH * 3 }, line4Path);
    if (!isDebugMode) line4.obj.alpha = 0;
    let line5 = drawLine(lineStyle, { x: lCircleXPos, y: 115 + lItemH * 4 }, line5Path);
    if (!isDebugMode) line5.obj.alpha = 0;
    let line6 = drawLine(lineStyle3, { x: lCircleXPos, y: 395 + lItemH / 2 }, line6Path);
    if (!isDebugMode) line6.obj.alpha = 0;
    let line7 = drawLine(
        lineStyle3,
        { x: lCircleXPos + lBox7Xoffset, y: 465 + lItemH / 2 },
        line7Path
    );
    if (!isDebugMode) line7.obj.alpha = 0;

    let bgRLine1 = drawLine(bgLineStyle, { x: rLinePathX, y: 231 }, rightLine1Path);
    let bgRLine2 = drawLine(bgLineStyle, { x: rLinePathX, y: 231 }, rightLine2Path);
    let bgRLine3 = drawLine(bgLineStyle, { x: rLinePathX, y: 231 }, rightLine3Path);
    let bgRLine4 = drawLine(bgLineStyle3, { x: rLinePathX, y: 259 }, rightLine4Path);
    let bgRLine5 = drawLine(bgLineStyle3, { x: rLinePathX, y: 259 }, rightLine5Path);
    let bgRLine6 = drawLine(bgLineStyle3, { x: rLinePathX, y: 259 }, rightLine6Path);

    let _bgRLine4 = drawLine(bgLineStyle2, { x: rLinePathX, y: 259 }, rightLine4Path); // for layering at the time of animation
    if (!isDebugMode) _bgRLine4.obj.alpha = 0;
    let _bgRLine5 = drawLine(bgLineStyle2, { x: rLinePathX, y: 259 }, rightLine5Path);
    if (!isDebugMode) _bgRLine5.obj.alpha = 0;
    let _bgRLine6 = drawLine(bgLineStyle2, { x: rLinePathX, y: 259 }, rightLine6Path);
    if (!isDebugMode) _bgRLine6.obj.alpha = 0;

    let rLine1 = drawLine(lineStyle, { x: rLinePathX, y: 231 }, rightLine1Path);
    if (!isDebugMode) rLine1.obj.alpha = 0;
    let rLine2 = drawLine(lineStyle, { x: rLinePathX, y: 231 }, rightLine2Path);
    if (!isDebugMode) rLine2.obj.alpha = 0;
    let rLine3 = drawLine(lineStyle, { x: rLinePathX, y: 231 }, rightLine3Path);
    if (!isDebugMode) rLine3.obj.alpha = 0;
    let rLine4 = drawLine(lineStyle3, { x: rLinePathX, y: 259 }, rightLine4Path);
    if (!isDebugMode) rLine4.obj.alpha = 0;
    let rLine5 = drawLine(lineStyle3, { x: rLinePathX, y: 259 }, rightLine5Path);
    if (!isDebugMode) rLine5.obj.alpha = 0;
    let rLine6 = drawLine(lineStyle3, { x: rLinePathX, y: 259 }, rightLine6Path);
    if (!isDebugMode) rLine6.obj.alpha = 0;

    let _rLine4 = drawLine(lineStyle2, { x: rLinePathX, y: 259 }, rightLine4Path);
    if (!isDebugMode) _rLine4.obj.alpha = 0;
    let _rLine5 = drawLine(lineStyle2, { x: rLinePathX, y: 259 }, rightLine5Path);
    if (!isDebugMode) _rLine5.obj.alpha = 0;
    let _rLine6 = drawLine(lineStyle2, { x: rLinePathX, y: 259 }, rightLine6Path);
    if (!isDebugMode) _rLine6.obj.alpha = 0;

    let dashOptions = [
        4, // space
        9 // dash
    ];
    let dashedRLine1 = drawDashedLine(rightLine1Path, dashLineStyle1, dashOptions, {
        x: rLinePathX,
        y: 231
    });
    let dashedRLine2 = drawDashedLine(rightLine2Path, dashLineStyle1, dashOptions, {
        x: rLinePathX,
        y: 231
    });
    let dashedRLine3 = drawDashedLine(rightLine3Path, dashLineStyle1, dashOptions, {
        x: rLinePathX,
        y: 231
    });
    let dashedRLine4 = drawDashedLine(rightLine4Path, dashLineStyle3, dashOptions, {
        x: rLinePathX,
        y: 259
    });
    let dashedRLine5 = drawDashedLine(rightLine5Path, dashLineStyle3, dashOptions, {
        x: rLinePathX,
        y: 259
    });
    let dashedRLine6 = drawDashedLine(rightLine6Path, dashLineStyle3, dashOptions, {
        x: rLinePathX,
        y: 259
    });

    console.log(line1Path.slice(0, -1));
    let dashedLine1 = drawDashedLine(line1Path.slice(0, -1), dashLineStyle1, dashOptions, {
        x: lCircleXPos,
        y: 115 + lItemH * 0
    });
    let dashedLine2 = drawDashedLine(line2Path.slice(0, -2), dashLineStyle1, dashOptions, {
        x: lCircleXPos,
        y: 115 + lItemH * 1
    });
    let dashedLine3 = drawDashedLine(line3Path, dashLineStyle1, dashOptions, {
        x: lCircleXPos,
        y: 115 + lItemH * 2
    });
    let dashedLine4 = drawDashedLine(line4Path.slice(0, -2), dashLineStyle1, dashOptions, {
        x: lCircleXPos,
        y: 115 + lItemH * 3
    });
    let dashedLine5 = drawDashedLine(line5Path.slice(0, -1), dashLineStyle1, dashOptions, {
        x: lCircleXPos,
        y: 115 + lItemH * 4
    });
    let dashedLine6 = drawDashedLine(line6Path, dashLineStyle3, dashOptions, {
        x: lCircleXPos,
        y: 395 + lItemH / 2
    });
    let dashedLine7 = drawDashedLine(line7Path, dashLineStyle3, dashOptions, {
        x: lCircleXPos + lBox7Xoffset,
        y: 465 + lItemH / 2
    });

    let lCircle1 = createCircle(
        color_lightGreen,
        3,
        lCircleXPos,
        l1y + 115 + lItemH * 0,
        color_darkGreen,
        2.5
    );
    if (!isDebugMode) lCircle1.alpha = 0;
    let lCircle2 = createCircle(
        color_lightGreen,
        3,
        lCircleXPos,
        l2y + 115 + lItemH * 1,
        color_darkGreen,
        2.5
    );
    if (!isDebugMode) lCircle2.alpha = 0;
    let lCircle3 = createCircle(
        color_lightGreen,
        3,
        lCircleXPos,
        115 + lItemH * 2,
        color_darkGreen,
        2.5
    );
    if (!isDebugMode) lCircle3.alpha = 0;
    let lCircle4 = createCircle(
        color_lightGreen,
        3,
        lCircleXPos,
        115 + lItemH * 3,
        color_darkGreen,
        2.5
    );
    if (!isDebugMode) lCircle4.alpha = 0;
    let lCircle5 = createCircle(
        color_lightGreen,
        3,
        lCircleXPos,
        115 + lItemH * 4,
        color_darkGreen,
        2.5
    );
    if (!isDebugMode) lCircle5.alpha = 0;

    let lCircle6 = createCircle(
        color_lightOrange,
        3,
        lCircleXPos,
        395 + lItemH / 2,
        color_darkOrange,
        2.5
    );
    if (!isDebugMode) lCircle6.alpha = 0;
    let lCircle7 = createCircle(color_lightOrange, 3, 345, 289, color_darkOrange, 2.5);
    if (!isDebugMode) lCircle7.alpha = 0;

    const tri1 = createTriangle(159, 115);
    const tri2 = createTriangle(159, 115 + lItemH * 1);
    const tri3 = createTriangle(159, 115 + lItemH * 2);
    const tri4 = createTriangle(159, 115 + lItemH * 3);
    const tri5 = createTriangle(159, 115 + lItemH * 4);
    const tri6 = createTriangle(159, 395 + lItemH / 2, 0xd0421f);
    const tri7 = createTriangle(325, 289, 0xd0421f, true);

    const rTri1 = createTriangle(rLinePathX, 231);
    const rTri2 = createTriangle(rLinePathX, 231);
    const rTri3 = createTriangle(rLinePathX, 231);

    const rTri4 = createTriangle(rLinePathX, 259, 0xd0421f);
    const rTri5 = createTriangle(rLinePathX, 259, 0xd0421f);
    const rTri6 = createTriangle(rLinePathX, 259, 0xd0421f);

    let rTxt1 = createText(textContent[langCode].r1, color_darkGreen, rBoxX, 81);
    if (!isDebugMode) rTxt1.alpha = 0;
    let rTxt2 = createText(textContent[langCode].r2, color_darkGreen, rBoxX, 81 + 53);
    if (!isDebugMode) rTxt2.alpha = 0;
    let rTxt3 = createText(textContent[langCode].r3, color_darkGreen, rBoxX, 81 + 106);
    if (!isDebugMode) rTxt3.alpha = 0;

    let rb1Height = 95;
    if (langCode !== "en") rb1Height += 22;
    let rBigBox1 = createBigBoxWithText(
        ...textContent[langCode].rb1,
        "r_icon_1",
        "r_icon_11",
        "r_icon_11",
        0
    );
    rBigBox1.x = rBoxX;
    rBigBox1.y = 220;
    if (!isDebugMode) rBigBox1.alpha = 0;
    let rBigBox1Text = rBigBox1.children.filter((c) => !!c._text);
    let rBigBox1Sprite = rBigBox1.children.filter((c) => c.isSprite && !c._text);
    //rBigBox1Sprite.forEach((sprite) => (sprite.filters = [colorMatrix]));
    let rBigBox1Lines = rBigBox1.children.filter((c) => !c.isSprite && !c._text);
    //rBigBox1Text.forEach((txt) => (txt.style.fill = color_darkGray));

    let rb2Height = 95;
    let rBigBox2 = createBigBoxWithText(
        ...textContent[langCode].rb2,
        "r_icon_2",
        "r_icon_21",
        "r_icon_21",
        1
    );
    rBigBox2.x = rBoxX;
    rBigBox2.y = 220 + rb1Height;
    let rBigBox2Text = rBigBox2.children.filter((c) => !!c._text);
    let rBigBox2Sprite = rBigBox2.children.filter((c) => c.isSprite && !c._text);
    //rBigBox2Sprite.forEach((sprite) => (sprite.filters = [colorMatrix]));
    let rBigBox2Lines = rBigBox2.children.filter((c) => !c.isSprite && !c._text);
    //rBigBox2Text.forEach((txt) => (txt.style.fill = color_darkGray));
    if (!isDebugMode) rBigBox2.alpha = 0;

    let rBigBox3 = createBigBoxWithText(
        ...textContent[langCode].rb3,
        "r_icon_3",
        "r_icon_31",
        "r_icon_31",
        2
    );
    rBigBox3.x = rBoxX;
    rBigBox3.y = 220 + rb1Height + rb2Height;
    let rBigBox3Text = rBigBox3.children.filter((c) => !!c._text);
    let rBigBox3Sprite = rBigBox3.children.filter((c) => c.isSprite && !c._text);
    //rBigBox3Sprite.forEach((sprite) => (sprite.filters = [colorMatrix]));
    let rBigBox3Lines = rBigBox3.children.filter((c) => !c.isSprite && !c._text);
    //rBigBox3Text.forEach((txt) => (txt.style.fill = color_darkGray));
    if (!isDebugMode) rBigBox3.alpha = 0;

    gsap.to(logoBgCircle1, {
        pixi: { alpha: 0.2 },
        duration: 1,
        yoyo: true,
        repeat: -1
    });
    gsap.to(logoBgCircle2, {
        pixi: { alpha: 0.2 },
        duration: 1,
        yoyo: true,
        delay: 0.1,
        repeat: -1
    });
    gsap.to(logoBgCircle3, {
        pixi: { alpha: 0.2 },
        duration: 1,
        delay: 0.3,
        yoyo: true,
        repeat: -1
    });

    let options = {
        root: document.querySelector("#animtion-container"),
        rootMargin: "0px",
        threshold: 0.75
    };

    let animationInitialized = false;
    let initiatedFromObserver = false;

    let observer = new IntersectionObserver((entries, observer) => {
        entries.forEach((entry) => {
            console.log("intersectionRatio", entry.intersectionRatio);
            if (entry.intersectionRatio > 0.5 && !initiatedFromObserver) {
                initiatedFromObserver = true;

                t1 = gsap.timeline({
                    repeat: 0,
                    onComplete: () => {
                        t1.clear();
                        setTimeout(
                            () => {
                                animate();
                            },
                            animationInitialized ? 600 : 0
                        );
                    }
                });
            }
        });
    }, options);
    let target = document.querySelector("#animation-container canvas");

    setTimeout(() => {
        observer.observe(target);
    }, 500);

    animate = () => {
        let arrDuration1 = 1.5;
        let arrDuration2 = arrDuration1 / 3;

        let l1PathPts = line1.path.split(" ").filter((p) => p !== "");
        let len = l1PathPts.length;
        let endPoints = `M${l1PathPts[len - 2]} ${l1PathPts[len - 1]}`;

        let rightSideAnimDelay = 0.25;

        if (!animationInitialized) {
            animationInitialized = true;
            t1.fromTo(
                [leftItem1, leftItem2, leftItem3, leftItem4, leftItem5, leftItem6, leftItem7],
                { pixi: { alpha: 0, scale: 0.1 } },
                { duration: 0.35, pixi: { alpha: 1, scale: 1 }, stagger: 0.03 },
                "stagger"
            );
            t1.fromTo(
                [rTxt1, rTxt2, rTxt3, rBigBox1, rBigBox2, rBigBox3],
                { pixi: { alpha: 0, scale: 0.1 } },
                { duration: 0.35, pixi: { alpha: 1, scale: 1 }, stagger: 0.03 },
                "stagger"
            );
            t1.fromTo(
                [
                    line1.obj,
                    line2.obj,
                    line3.obj,
                    line4.obj,
                    line5.obj,
                    line6.obj,
                    line7.obj,
                    rLine1.obj,
                    rLine2.obj,
                    rLine3.obj,
                    rLine4.obj,
                    rLine5.obj,
                    rLine6.obj
                ],
                { pixi: { alpha: 0 } },
                { duration: 0.35, pixi: { alpha: 1 }, stagger: 0.02 }
            );

            t1.to(
                [lCircle1, lCircle2, lCircle3, lCircle4, lCircle5, lCircle6, lCircle7],
                {
                    duration: 0.35,
                    pixi: { alpha: 1 },
                    stagger: 0.05
                },
                "<"
            );
            t1.to(leftItem1, { duration: 0.1 });
        } else {
            t1.to(
                [
                    leftItem1,
                    leftItem2,
                    leftItem3,
                    leftItem4,
                    leftItem5,
                    leftItem6,
                    leftItem7,
                    rTxt1,
                    rTxt2,
                    rTxt3,
                    rBigBox1,
                    rBigBox2,
                    rBigBox3
                ],
                {
                    duration: 0,
                    pixi: { alpha: 1, scale: 1 }
                }
            );
            t1.to(
                [
                    lCircle1,
                    lCircle2,
                    lCircle3,
                    lCircle4,
                    lCircle5,
                    lCircle6,
                    lCircle7,
                    line1.obj,
                    line2.obj,
                    line3.obj,
                    line4.obj,
                    line5.obj,
                    line6.obj,
                    line7.obj,
                    rLine1.obj,
                    rLine2.obj,
                    rLine3.obj,
                    rLine4.obj,
                    rLine5.obj,
                    rLine6.obj
                ],
                {
                    duration: 0,
                    pixi: { alpha: 1 }
                }
            );
        }

        t1.to(rBigBox1Lines, {
            duration: 0,
            pixi: { lineColor: color_darkOrange }
        });
        t1.to(rBigBox2Lines, {
            duration: 0,
            pixi: { lineColor: color_darkOrange }
        });
        t1.to(rBigBox3Lines, {
            duration: 0,
            pixi: { lineColor: color_darkOrange }
        });
        t1.to(rBGCircle_l2_1, {
            duration: 0,
            pixi: { fillColor: color_lightOrange }
        });
        t1.to(rBGCircle4_2, {
            duration: 0,
            pixi: { fillColor: color_lightOrange }
        });
        t1.to([lBGCircle6_1, lBGCircle6_2, rBGCircle5_2], {
            duration: 0,
            pixi: { fillColor: color_lightOrange }
        });
        t1.to(lCircle6, {
            duration: 0,
            pixi: { lineColor: color_darkOrange }
        });
        t1.to([lBGCircle7_1, lBGCircle7_2, rBGCircle6_2], {
            duration: 0,
            pixi: { fillColor: color_lightOrange }
        });
        t1.to(lCircle7, {
            duration: 0,
            pixi: { lineColor: color_darkOrange }
        });

        t1.to(rBigBox1Text, {
            duration: 0,
            onComplete: function () {
                this._targets.forEach((txt) => (txt.style.fill = color_darkOrange));
            }
        });
        t1.to(rBigBox1Sprite, {
            duration: 0,
            onComplete: function () {
                this._targets.forEach((sprite) => (sprite.filters = []));
            }
        });
        t1.to(rBigBox2Text, {
            duration: 0,
            onComplete: function () {
                [...this._targets, leftItem6Text].forEach(
                    (txt) => (txt.style.fill = color_darkOrange)
                );
            }
        });
        t1.to(rBigBox2Sprite, {
            duration: 0,
            onComplete: function () {
                [...this._targets, leftItem6Sprite].forEach((sprite) => (sprite.filters = []));
            }
        });
        t1.to(rBigBox3Text, {
            duration: 0,
            onComplete: function () {
                [...this._targets, leftItem7Text].forEach(
                    (txt) => (txt.style.fill = color_darkOrange)
                );
            }
        });
        t1.to(rBigBox3Sprite, {
            duration: 0,
            onComplete: function () {
                [...this._targets, leftItem7Sprite].forEach((sprite) => (sprite.filters = []));
            }
        });

        t1.to(rLine4.obj, {
            duration: 0.01,
            pixi: { lineColor: color_darkOrange }
        });
        t1.to(
            bgRLine4.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_lightOrange }
            },
            "<"
        );
        t1.to(
            rLine5.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_darkOrange }
            },
            "<"
        );
        t1.to(
            bgRLine5.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_lightOrange }
            },
            "<"
        );
        t1.to(
            rLine6.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_darkOrange }
            },
            "<"
        );
        t1.to(
            bgRLine6.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_lightOrange }
            },
            "<"
        );
        t1.to(
            line6.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_darkOrange }
            },
            "<"
        );
        t1.to(
            bgLine6.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_lightOrange }
            },
            "<"
        );
        t1.to(
            line7.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_darkOrange }
            },
            "<"
        );
        t1.to(
            bgLine7.obj,
            {
                duration: 0.01,
                pixi: { lineColor: color_lightOrange }
            },
            "<"
        );
        t1.to(
            [_rLine4.obj, _bgRLine4.obj],
            {
                duration: 0.01,
                pixi: { alpha: 1 }
            },
            "<"
        );
        t1.to(
            [_rLine5.obj, _bgRLine5.obj],
            {
                duration: 0.01,
                pixi: { alpha: 1 }
            },
            "<"
        );
        t1.to(
            [_rLine6.obj, _bgRLine6.obj],
            {
                duration: 0.01,
                pixi: { alpha: 1 }
            },
            "<"
        );

        t1.to(rTri1, { duration: 0, alpha: 0 });
        t1.to(rTri2, { duration: 0, alpha: 0 });
        t1.to(rTri3, { duration: 0, alpha: 0 });
        t1.to(rTri4, { duration: 0, alpha: 0 });
        t1.to(rTri5, { duration: 0, alpha: 0 });
        t1.to(rTri6, { duration: 0, alpha: 0 });
        t1.to(tri7, { duration: 0, alpha: 0 });

        t1.to(tri1, { duration: 0, alpha: 1 });
        t1.to(tri2, { duration: 0, alpha: 1 });
        t1.to(tri3, { duration: 0, alpha: 1 });
        t1.to(tri4, { duration: 0, alpha: 1 });
        t1.to(tri5, { duration: 0, alpha: 1 });
        t1.to(tri6, { duration: 0, alpha: 1 });
        t1.to(tri1, {
            duration: arrDuration1,
            ease: "none",
            //repeat: -1,
            motionPath: {
                autoRotate: 0,
                path: l1PathPts.join(" "), //"M159,115 h70 c20,0 20,0 20,20 v76 c0,20 0,20, 20,20",
                useRadians: true
            }
        });
        t1.to(
            tri2,
            {
                duration: arrDuration1,
                ease: "none",
                //repeat: -1,
                motionPath: {
                    autoRotate: 0,
                    path: line2.path,
                    useRadians: true
                }
            },
            "<"
        );
        t1.to(
            tri3,
            {
                duration: arrDuration1,
                ease: "none",
                //repeat: -1,
                motionPath: {
                    autoRotate: 0,
                    path: line3.path,
                    useRadians: true
                }
            },
            "<"
        );
        t1.to(
            tri4,
            {
                duration: arrDuration1,
                ease: "none",
                motionPath: {
                    autoRotate: 0,
                    path: line4.path,
                    useRadians: true
                }
            },
            "<"
        );
        t1.to(
            tri5,
            {
                duration: arrDuration1,
                ease: "none",
                motionPath: {
                    autoRotate: 0,
                    path: line5.path,
                    useRadians: true
                }
            },
            "<"
        )
            .to(
                tri6,
                {
                    duration: arrDuration1,
                    ease: "none",
                    motionPath: {
                        autoRotate: 0,
                        path: line6.path,
                        useRadians: true
                    }
                },
                "<"
            )
            .to(tri1, { duration: 0, alpha: 0 })
            .to(tri2, { duration: 0, alpha: 0 })
            .to(tri3, { duration: 0, alpha: 0 })
            .to(tri4, { duration: 0, alpha: 0 })
            .to(tri5, { duration: 0, alpha: 0 })
            .to(tri6, { duration: 0, alpha: 0 })
            .to(rTri1, { delay: rightSideAnimDelay, duration: 0, alpha: 1 })
            .to(rTri2, { duration: 0, alpha: 1 }, "<")
            .to(rTri3, { duration: 0, alpha: 1 }, "<");
        t1.to(rTri4, { duration: 0, alpha: 1 }, "<");
        t1.to(rTri5, { duration: 0, alpha: 1 }, "<");
        t1.to(rTri6, { duration: 0, alpha: 1 }, "<");
        t1.to(tri7, { duration: 0, alpha: 1 }, "<")
            .to(
                rTri1,
                {
                    duration: arrDuration1,
                    ease: "none",
                    motionPath: {
                        autoRotate: 0,
                        path: rLine1.path,
                        useRadians: true
                    }
                },
                "rightAnim"
            )
            .to(
                rTri2,
                {
                    duration: arrDuration1,
                    ease: "none",
                    motionPath: {
                        autoRotate: 0,
                        path: rLine2.path,
                        useRadians: true
                    }
                },
                "<"
            )
            .to(
                rTri3,
                {
                    duration: arrDuration1,
                    ease: "none",
                    motionPath: {
                        autoRotate: 0,
                        path: rLine3.path,
                        useRadians: true
                    }
                },
                "<"
            );
        t1.to(
            rTri4,
            {
                duration: arrDuration1,
                ease: "none",
                motionPath: {
                    autoRotate: 0,
                    path: rLine4.path,
                    useRadians: true
                }
            },
            "<"
        );
        t1.to(
            rTri5,
            {
                duration: arrDuration1,
                ease: "none",
                motionPath: {
                    autoRotate: 0,
                    path: rLine5.path,
                    useRadians: true
                }
            },
            "<"
        );
        t1.to(
            rTri6,
            {
                duration: arrDuration1,
                ease: "none",
                motionPath: {
                    autoRotate: 0,
                    path: rLine6.path,
                    useRadians: true
                }
            },
            "<"
        );
        t1.to(
            tri7,
            {
                duration: arrDuration1,
                ease: "none",
                motionPath: {
                    autoRotate: 0,
                    path: line7.path,
                    useRadians: true
                }
            },
            "<"
        )
            .to(rTri1, { duration: 0.5, alpha: 1, pixi: { scale: 1 } })
            .to(rTri2, { duration: 0.5, alpha: 1, pixi: { scale: 1 } }, "<")
            .to(rTri3, { duration: 0.5, alpha: 1, pixi: { scale: 1 } }, "<")
            .to(rTri4, { duration: 0.5, alpha: 1, pixi: { scale: 1 } }, "<")
            .to(rTri5, { duration: 0.5, alpha: 1, pixi: { scale: 1 } }, "<")
            .to(rTri6, { duration: 0.5, alpha: 1, pixi: { scale: 1 } }, "<")
            .to(tri7, { duration: 0.5, alpha: 1 }, "<");
    };

    // MotionPathHelper.create("#arrow", {
    //     path: path1
    // });
}

// let animStageListElems = [...document.querySelectorAll("section.animations .stages ul li")];
// animStageListElems.forEach((stageElem, i) => {
//     stageElem.addEventListener("click", () => {
//         animStageListElems.forEach((elem) => elem.classList.remove("active"));
//         stageElem.classList.add("active");

//         t1.clear();
//         //t1.seek(0);
//         t1.progress(1, false);
//         animStateIndex = i;
//         animate(i);
//     });
// });
